ALLOWED_GUILD_ID = 692143509259419719
ALLOWED_USER_ID = 367664282990804992
CANAL_DESTINO_ID = 1359260714551873698  # Substitua pelo ID do canal desejado

import discord
from discord.ext import commands
import os
from groq import Groq
from dotenv import load_dotenv
from serpapi import GoogleSearch
from flask import Flask
from threading import Thread
from collections import defaultdict, deque
import datetime
import asyncio
from discord.ext import tasks
import json
import re
from github_uploader import upload_to_github

conversas = defaultdict(lambda: deque(maxlen=10))

load_dotenv()

# Configura√ß√µes do Discord
intents = discord.Intents.default()
intents.messages = True
intents.message_content = True

bot = commands.Bot(command_prefix="!", intents=intents, case_insensitive=True)

# Chaves das APIs (deixe no .env)
GROQ_API_KEY = os.getenv("GROQ_API_KEY")
DISCORD_TOKEN = os.getenv("DISCORD_TOKEN")
SERPAPI_KEY = os.getenv("SERPAPI_KEY")  # Lembre de adicionar ao .env

# Inicializa o cliente Groq
groq_client = Groq(api_key=GROQ_API_KEY)

# Fun√ß√£o de busca na web com SerpApi
def buscar_na_web(consulta):
    try:
        search = GoogleSearch({
            "q": consulta,
            "hl": "pt-br",
            "gl": "br",
            "api_key": SERPAPI_KEY
        })
        resultados = search.get_dict()

        respostas = []
        if "organic_results" in resultados:
            for resultado in resultados["organic_results"][:3]:
                titulo = resultado.get("title", "")
                snippet = resultado.get("snippet", "")
                respostas.append(f"{titulo}: {snippet}")

        return "\n".join(respostas) if respostas else "Nenhum resultado encontrado."
    except Exception as e:
        return f"Erro ao buscar na web: {e}"


@bot.event
async def on_ready():
    print(f"ü§ñ Bot conectado como {bot.user}")

# Verifica√ß√£o de autoriza√ß√£o
def autorizado(ctx):
    # Permite se for no servidor autorizado
    if ctx.guild and ctx.guild.id == ALLOWED_GUILD_ID:
        return True
    # Permite se for uma DM com o usu√°rio autorizado
    if ctx.guild is None and ctx.author.id == ALLOWED_USER_ID:
        return True
    return False

@bot.command()
async def ask(ctx, *, pergunta):
    if not autorizado(ctx):
        return await ctx.send("‚ùå Este bot s√≥ pode ser usado em um servidor autorizado.")

    canal_id = ctx.channel.id
    historico = conversas[canal_id]

    # Adiciona a nova pergunta ao hist√≥rico
    historico.append({"role": "user", "content": pergunta})

    mensagens = [{"role": "system", "content": "Voc√™ √© um assistente √∫til e simp√°tico."}] + list(historico)

    try:
        response = groq_client.chat.completions.create(
            model="meta-llama/llama-4-scout-17b-16e-instruct",
            messages=mensagens
        )
        resposta = response.choices[0].message.content

        # Salva a resposta no hist√≥rico
        historico.append({"role": "assistant", "content": resposta})

        await ctx.send(resposta)

    except Exception as e:
        print(f"Erro: {e}")
        await ctx.send("‚ùå Ocorreu um erro ao processar sua pergunta.")

@bot.command()
async def search(ctx, *, consulta):
    if not autorizado(ctx):
        return await ctx.send("‚ùå Este bot s√≥ pode ser usado em um servidor autorizado.")

    await ctx.send("üîé Buscando na internet...")

    dados = buscar_na_web(consulta)

    canal_id = ctx.channel.id
    historico = conversas[canal_id]

    prompt = f"""
    Um usu√°rio fez a seguinte pergunta: \"{consulta}\".
    Aqui est√£o os resultados da pesquisa online:

    {dados}

    Responda de forma clara, √∫til e direta com base nesses dados:
    """

    historico.append({"role": "user", "content": prompt})

    mensagens = [{"role": "system", "content": "Voc√™ √© um assistente inteligente e √∫til."}] + list(historico)

    try:
        response = groq_client.chat.completions.create(
            model="meta-llama/llama-4-scout-17b-16e-instruct",
            messages=mensagens
        )
        resposta = response.choices[0].message.content

        historico.append({"role": "assistant", "content": resposta})

        await ctx.send(resposta)

    except Exception as e:
        print(f"Erro: {e}")
        await ctx.send("‚ùå Ocorreu um erro ao processar sua busca com IA.")


@bot.command()
async def testar_conteudo(ctx):
    if not autorizado(ctx):
        return await ctx.send("‚ùå Este bot s√≥ pode ser usado em um servidor autorizado.")

    conteudo = await gerar_conteudo_com_ia()
    await ctx.send(conteudo)


# Armazena hist√≥rico para evitar repeti√ß√µes
historico_palavras = set()
historico_frases = set()


@tasks.loop(minutes=1)
async def enviar_conteudo_diario():
    agora = datetime.datetime.now()
    if agora.hour == 9 and agora.minute == 0:
        canal = bot.get_channel(CANAL_DESTINO_ID)
        if canal:
            conteudo = await gerar_conteudo_com_ia()
            await canal.send(conteudo)
        await asyncio.sleep(60)  # Evita m√∫ltiplos envios √†s 09:00

@enviar_conteudo_diario.before_loop
async def before():
    await bot.wait_until_ready()


async def gerar_conteudo_com_ia():
    # ... (c√≥digo anterior) ...
    try:
        with open("historico.json", "r", encoding="utf-8") as f:
            historico = json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        historico = {"palavras": [], "frases": []}

    for _ in range(10):
        prompt = """
Crie duas coisas para um canal de aprendizado:

1. Uma palavra em ingl√™s com:
- Significado
- Um exemplo de frase em ingl√™s (com tradu√ß√£o).

2. Uma frase estoica com:
- Autor (se souber)
- Pequena explica√ß√£o/reflex√£o em portugu√™s.

Formato:
Palavra: ...
Significado: ...
Exemplo: ...
Tradu√ß√£o: ...

Frase estoica: "..."
Autor: ...
Reflex√£o: ...
"""
        try: # In√≠cio do try principal
            response = groq_client.chat.completions.create(
                model="meta-llama/llama-4-scout-17b-16e-instruct",
                messages=[
                    {"role": "system", "content": "Voc√™ √© um professor de ingl√™s e filosofia estoica, escrevendo para um canal no Discord."},
                    {"role": "user", "content": prompt}
                ]
            )
            conteudo = response.choices[0].message.content

            match_palavra = re.search(r"(?i)^palavra:\s*(.+)", conteudo, re.MULTILINE)
            match_frase = re.search(r"(?i)^frase estoica:\s*\"?(.+?)\"?", conteudo, re.MULTILINE)

            if match_palavra and match_frase:
                palavra = match_palavra.group(1).strip()
                frase = match_frase.group(1).strip()

                if palavra not in historico["palavras"] and frase not in historico["frases"]:
                    historico["palavras"].append(palavra)
                    historico["frases"].append(frase)

                    # Salva localmente e depois tenta o upload DENTRO do 'with'
                    with open("historico.json", "w", encoding="utf-8") as f:
                        json.dump(historico, f, indent=2, ensure_ascii=False)
                        print("‚úÖ Hist√≥rico salvo localmente em:", os.path.abspath("historico.json"))

                        # --- IN√çCIO DO BLOCO MOVIDO E CORRIGIDO ---
                        try: # Adiciona um try/except espec√≠fico para o upload (opcional, mas bom)
                            print("Tentando enviar historico.json para o GitHub...")
                            status, resp = upload_to_github()
                            if status == 201 or status == 200:
                                print("‚úÖ Hist√≥rico atualizado no GitHub.")
                            else:
                                # Imprime mais detalhes do erro do GitHub
                                print(f"‚ö†Ô∏è Erro ao enviar para o GitHub (Status: {status}): {resp}")
                        except Exception as upload_err:
                            print(f"‚ùå Exce√ß√£o durante o upload para o GitHub: {upload_err}")
                        # --- FIM DO BLOCO MOVIDO E CORRIGIDO ---

                    return conteudo # Retorna o conte√∫do se tudo deu certo (save local + tentativa de upload)

            # Este else agora est√° no lugar certo em rela√ß√£o ao except principal
            else:
                print("‚ö†Ô∏è N√£o foi poss√≠vel extrair a palavra ou frase do conte√∫do gerado:")
                print(conteudo)
                # Corrigido: a l√≥gica de impress√£o de repetido estava fora do lugar
                # Removido as linhas abaixo daqui pois 'palavra' e 'frase' podem n√£o existir se o regex falhou
                # print("‚ö†Ô∏è Conte√∫do repetido detectado.")
                # print("Palavra:", palavra)
                # print("Frase:", frase)

        # Este except agora segue corretamente o bloco try principal
        except Exception as e:
            # Mensagem mais espec√≠fica para erro na gera√ß√£o/processamento
            print(f"‚ùå Erro ao gerar conte√∫do ou processar resposta da IA: {e}")
            # Mant√©m o retorno original para sinalizar falha na gera√ß√£o
            return f"‚ùå Erro ao gerar conte√∫do di√°rio: {e}"

        # Adicionado um print se o conte√∫do for repetido, dentro do loop
        if 'palavra' in locals() and 'frase' in locals() and (palavra in historico["palavras"] or frase in historico["frases"]):
             print(f"‚ö†Ô∏è Conte√∫do repetido detectado (Palavra: '{palavra}', Frase: '{frase}'). Tentando novamente...")

        # Pequena pausa para n√£o sobrecarregar a API em caso de repeti√ß√µes r√°pidas
        await asyncio.sleep(1)


    # Mensagem se o loop terminar sem sucesso
    print("‚ö†Ô∏è N√£o foi poss√≠vel gerar um conte√∫do in√©dito ap√≥s 10 tentativas.")
    return "‚ö†Ô∏è N√£o foi poss√≠vel gerar um conte√∫do in√©dito ap√≥s 10 tentativas."



# ------ Servidor Flask ------
app = Flask(__name__)

@app.route("/")
def home():
    return "Bot is online!"

def run_server():
    # O Render define a porta na vari√°vel de ambiente PORT
    port = int(os.environ.get("PORT", 5000))
    app.run(host="0.0.0.0", port=port)

# ------ In√≠cio da aplica√ß√£o ------
if __name__ == "__main__":
    # Inicia o servidor Flask em uma thread
    Thread(target=run_server).start()
    enviar_conteudo_diario.start()


# Roda o bot
bot.run(DISCORD_TOKEN)
